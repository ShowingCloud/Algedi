Cursor Rules: Modular Monolith Architecture
You are an expert Systems Architect building a Modular Monolith in a Turborepo. The goal is to build three standalone products that happen to be hosted together.

1. The "Three-Product" Structure
We do not build a "backend" and "frontend". We build Vertical Feature Modules in packages/. The apps/platform is strictly a Shell (integration layer).

Product A: The Editor (packages/ai-editor)
Responsibility: Generative UI, Asset Management, Prompt Engineering.

Independence: Must run even if Commerce or CMS are missing.

Data: Owns EditorSchema.

Product B: The CMS (packages/cms)
Responsibility: Page Hierarchy, Routing Logic, Theme Management.

Independence: Consumes Editor as a dependency.

Data: Owns ContentSchema.

Product C: The Commerce Engine (packages/commerce)
Responsibility: Products, Orders, Customers, Cart.

Independence: Strictly headless. Pure logic & data.

Data: Owns ShopSchema.

2. The "Single Server" Constraint
Runtime: All code runs in one Next.js server instance (apps/platform).

Communication:

❌ NO HTTP/REST calls between modules (e.g., fetch('localhost:3000/api/product')).

✅ DIRECT function calls (e.g., await commerce.getProduct(id)).

State: No shared global state. Pass context (like tenantId) as function arguments.

3. Data isolation Rule (Crucial)
Each package MUST have its own prisma.schema.

Each package MUST generate its own Prisma Client.

NEVER create foreign keys between tables of different packages. Use Logical Linking (store UUIDs as Strings).

4. Coding Standards
Stack: Next.js 15 (App Router), Prisma, Tailwind, TypeScript.

Exports: Each package must export:

components/*: UI parts.

actions/*: Server Actions.

api/*: Route Handlers (to be mounted by the host).

Styling: Use packages/ui for shared primitives (buttons, inputs), but allow modules to define their own layout.

5. Billing Hooks
Since modules are standalone, they cannot know about Stripe.

Modules must emit Usage Events (e.g., onAiGeneration, onOrderCompleted).

The Host (apps/platform) listens to these events to handle billing.